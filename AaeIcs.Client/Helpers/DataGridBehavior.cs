using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Threading;

namespace AAEICS.Client.Helpers;

public static class DataGridBehavior
{
    public static readonly DependencyProperty KeepEditingTextProperty =
        DependencyProperty.RegisterAttached(
            "KeepEditingText",
            typeof(bool),
            typeof(DataGridBehavior),
            new PropertyMetadata(false, OnKeepEditingTextChanged));
    
    public static readonly DependencyProperty AutoFormatGeneratedColumnsProperty =
        DependencyProperty.RegisterAttached(
            "AutoFormatGeneratedColumns",
            typeof(bool),
            typeof(DataGridBehavior),
            new PropertyMetadata(false, OnAutoFormatGeneratedColumnsChanged));
    
    private static readonly DependencyProperty SavedOriginalTextProperty =
        DependencyProperty.RegisterAttached(
            "SavedOriginalText", 
            typeof(string), 
            typeof(DataGridBehavior));

    public static bool GetKeepEditingText(DependencyObject obj) => 
        (bool)obj.GetValue(KeepEditingTextProperty);
    public static void SetKeepEditingText(DependencyObject obj, bool value) => 
        obj.SetValue(KeepEditingTextProperty, value);

    public static bool GetAutoFormatGeneratedColumns(DependencyObject obj) => 
        (bool)obj.GetValue(AutoFormatGeneratedColumnsProperty);
    public static void SetAutoFormatGeneratedColumns(DependencyObject obj, bool value) => 
        obj.SetValue(AutoFormatGeneratedColumnsProperty, value);
    
    private static void OnKeepEditingTextChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        if (d is not DataGrid dataGrid) return;
        
        if ((bool)e.NewValue)
        {
            dataGrid.BeginningEdit += DataGrid_BeginningEdit;
            dataGrid.PreparingCellForEdit += DataGrid_PreparingCellForEdit;
        }
        else
        {
            dataGrid.BeginningEdit -= DataGrid_BeginningEdit;
            dataGrid.PreparingCellForEdit -= DataGrid_PreparingCellForEdit;
        }
    }
    
    private static void DataGrid_BeginningEdit(object? sender, DataGridBeginningEditEventArgs e)
    {
        if (sender is not DataGrid dataGrid) return;
        
        if (e.Column is DataGridTextColumn)
        {
            var cellContent = e.Column.GetCellContent(e.Row);
            if (cellContent is TextBlock textBlock)
                dataGrid.SetValue(SavedOriginalTextProperty, textBlock.Text);
        }
    }
    
    private static void DataGrid_PreparingCellForEdit(object? sender, DataGridPreparingCellForEditEventArgs e)
    {
        if (e.EditingElement is not TextBox textBox || sender is not DataGrid dataGrid) return;
        
        string originalText = (string)dataGrid.GetValue(SavedOriginalTextProperty) ?? string.Empty;
        
        if (e.EditingEventArgs is TextCompositionEventArgs textArgs)
        {
            textBox.Text = originalText + textArgs.Text;
            
            textArgs.Handled = true;
            
            Application.Current.Dispatcher.BeginInvoke(new Action(() =>
            {
                textBox.Focus();
                textBox.SelectionLength = 0;
                textBox.CaretIndex = textBox.Text.Length;
            }), DispatcherPriority.Normal);
        }
        else
        {
            Application.Current.Dispatcher.BeginInvoke(new Action(() =>
            {
                textBox.Focus();
                textBox.SelectionLength = 0;
                textBox.CaretIndex = textBox.Text.Length;
            }), DispatcherPriority.Background);
        }
    }

    private static void OnAutoFormatGeneratedColumnsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
    {
        if (d is not DataGrid dataGrid) return;

        if ((bool)e.NewValue)
        {
            dataGrid.AutoGeneratingColumn += DataGrid_AutoGeneratingColumn;
            dataGrid.AutoGeneratedColumns += DataGrid_AutoGeneratedColumns;
        }
        else
        {
            dataGrid.AutoGeneratingColumn -= DataGrid_AutoGeneratingColumn;
            dataGrid.AutoGeneratedColumns -= DataGrid_AutoGeneratedColumns;
        }
    }

    private static void DataGrid_AutoGeneratingColumn(object? sender, DataGridAutoGeneratingColumnEventArgs e)
    {
        // 1. Приховуємо властивості, які ми ВЖЕ прописали в XAML вручну
        // Увага: ЗАМІНИ ці імена на реальні назви властивостей з твоєї моделі!
        if (e.PropertyName == "IsConfirmed" || 
            e.PropertyName == "MeasureUnit" ||
            e.PropertyName == "QuantitySent" || 
            e.PropertyName == "CategorySent" || 
            e.PropertyName == "QuantityReceived" || 
            e.PropertyName == "CategoryReceived")
        {
            // Кажемо WPF: "Не роби для них окремих колонок, ми самі з ними розібралися!"
            e.Cancel = true;
            return;
        }
// ==========================================
        // ЛОГІКА ЧИТАННЯ ЛОКАЛІЗАЦІЇ З .RESX
        // ==========================================
        if (e.PropertyDescriptor is PropertyDescriptor descriptor)
        {
            // Шукаємо атрибут DisplayAttribute замість DisplayNameAttribute
            var displayAttr = descriptor.Attributes.OfType<DisplayAttribute>().FirstOrDefault();
            
            if (displayAttr != null)
            {
                // Метод GetName() робить усю магію: він сам іде у файл .resx, 
                // дивиться поточну культуру програми (Thread.CurrentUICulture) і дістає потрібний текст!
                string localizedHeader = displayAttr.GetName();
                
                if (!string.IsNullOrEmpty(localizedHeader))
                {
                    e.Column.Header = localizedHeader;
                }
            }
        }
        // ==========================================

        // 2. Стилізуємо автоматично згенеровані текстові колонки (залишається без змін)
        if (e.Column is DataGridTextColumn textColumn && sender is FrameworkElement element)
        {
            textColumn.ElementStyle = (Style)element.FindResource("WrapTextElementStyle");
            textColumn.EditingElementStyle = (Style)element.FindResource("WrapTextEditingStyle");
            textColumn.CellStyle = (Style)element.FindResource("LockableCellStyle");
            
            textColumn.Width = new DataGridLength(1, DataGridLengthUnitType.Star);
        }
    }

    private static void DataGrid_AutoGeneratedColumns(object? sender, EventArgs e)
    {
        if (sender is not DataGrid grid) return;

        // 1. Знаходимо всі колонки, які DataGrid згенерував сам 
        // (у DataGridColumn є вбудована властивість IsAutoGenerated, яка ідеально нам підходить)
        var autoGeneratedColumns = grid.Columns.Where(c => c.IsAutoGenerated).ToList();

        // 2. Визначаємо, з якого індексу ми почнемо їх вставляти.
        // Індекс 0 залізно зарезервований за нашим кастомним Чекбоксом, тому починаємо з 1.
        int insertIndex = 1;

        // 3. Беремо кожну згенеровану колонку і ставимо її одразу після чекбоксу
        foreach (var col in autoGeneratedColumns)
        {
            if ((string)col.Header == "Notes") // Якщо це колонка "Notes", ставимо її в кінець (перед Operations)
            {
                col.DisplayIndex = grid.Columns.Count - 3; // Передостанній індекс
                continue;
            }

            col.DisplayIndex = insertIndex;
            insertIndex++; // Наступна згенерована колонка стане після цієї
        }

        // РЕЗУЛЬТАТ:
        // [0: Чекбокс] -> [1: АвтоКолонка_1] -> [2: АвтоКолонка_2] -> 
        // [3: Об'єднана 1] -> [4: Об'єднана 2] -> [5: Operations]
    }
}